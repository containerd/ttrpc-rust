// This file is generated by ttrpc-codegen 1.0.0. Do not edit
// @generated

#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateContainerRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exec_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub string_user: ::core::option::Option<StringUser>,
    #[prost(message, repeated, tag = "4")]
    pub devices: ::prost::alloc::vec::Vec<Device>,
    #[prost(message, repeated, tag = "5")]
    pub storages: ::prost::alloc::vec::Vec<Storage>,
    #[prost(message, optional, tag = "6")]
    pub oci: ::core::option::Option<super::oci::Spec>,
    /// This field is used to indicate if the container needs to join
    /// sandbox shared pid ns or create a new namespace. This field is
    /// meant to override the NEWPID config settings in the OCI spec.
    /// The agent would receive an OCI spec with PID namespace cleared
    /// out altogether and not just the pid ns path.
    #[prost(bool, tag = "7")]
    pub sandbox_pidns: bool,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartContainerRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RemoveContainerRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    /// RemoveContainer will return an error if
    /// it could not kill some container processes
    /// after timeout seconds.
    /// Setting timeout to 0 means RemoveContainer will
    /// wait for ever.
    #[prost(uint32, tag = "2")]
    pub timeout: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecProcessRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exec_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub string_user: ::core::option::Option<StringUser>,
    #[prost(message, optional, tag = "4")]
    pub process: ::core::option::Option<super::oci::Process>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalProcessRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    /// Special case for SignalProcess(): exec_id can be empty(""),
    /// which means to send the signal to all the processes including their descendants.
    /// Other APIs with exec_id should treat empty exec_id as an invalid request.
    #[prost(string, tag = "2")]
    pub exec_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub signal: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitProcessRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exec_id: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WaitProcessResponse {
    #[prost(int32, tag = "1")]
    pub status: i32,
}
/// ListProcessesRequest contains the options used to list running processes inside the container
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProcessesRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub format: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// ListProcessesResponse represents the list of running processes inside the container
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListProcessesResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub process_list: ::prost::alloc::vec::Vec<u8>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateContainerRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub resources: ::core::option::Option<super::oci::LinuxResources>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsContainerRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PauseContainerRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResumeContainerRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuUsage {
    #[prost(uint64, tag = "1")]
    pub total_usage: u64,
    #[prost(uint64, repeated, tag = "2")]
    pub percpu_usage: ::prost::alloc::vec::Vec<u64>,
    #[prost(uint64, tag = "3")]
    pub usage_in_kernelmode: u64,
    #[prost(uint64, tag = "4")]
    pub usage_in_usermode: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ThrottlingData {
    #[prost(uint64, tag = "1")]
    pub periods: u64,
    #[prost(uint64, tag = "2")]
    pub throttled_periods: u64,
    #[prost(uint64, tag = "3")]
    pub throttled_time: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CpuStats {
    #[prost(message, optional, tag = "1")]
    pub cpu_usage: ::core::option::Option<CpuUsage>,
    #[prost(message, optional, tag = "2")]
    pub throttling_data: ::core::option::Option<ThrottlingData>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PidsStats {
    #[prost(uint64, tag = "1")]
    pub current: u64,
    #[prost(uint64, tag = "2")]
    pub limit: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryData {
    #[prost(uint64, tag = "1")]
    pub usage: u64,
    #[prost(uint64, tag = "2")]
    pub max_usage: u64,
    #[prost(uint64, tag = "3")]
    pub failcnt: u64,
    #[prost(uint64, tag = "4")]
    pub limit: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemoryStats {
    #[prost(uint64, tag = "1")]
    pub cache: u64,
    #[prost(message, optional, tag = "2")]
    pub usage: ::core::option::Option<MemoryData>,
    #[prost(message, optional, tag = "3")]
    pub swap_usage: ::core::option::Option<MemoryData>,
    #[prost(message, optional, tag = "4")]
    pub kernel_usage: ::core::option::Option<MemoryData>,
    #[prost(bool, tag = "5")]
    pub use_hierarchy: bool,
    #[prost(map = "string, uint64", tag = "6")]
    pub stats: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlkioStatsEntry {
    #[prost(uint64, tag = "1")]
    pub major: u64,
    #[prost(uint64, tag = "2")]
    pub minor: u64,
    #[prost(string, tag = "3")]
    pub op: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub value: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlkioStats {
    /// number of bytes transferred to and from the block device
    #[prost(message, repeated, tag = "1")]
    pub io_service_bytes_recursive: ::prost::alloc::vec::Vec<BlkioStatsEntry>,
    #[prost(message, repeated, tag = "2")]
    pub io_serviced_recursive: ::prost::alloc::vec::Vec<BlkioStatsEntry>,
    #[prost(message, repeated, tag = "3")]
    pub io_queued_recursive: ::prost::alloc::vec::Vec<BlkioStatsEntry>,
    #[prost(message, repeated, tag = "4")]
    pub io_service_time_recursive: ::prost::alloc::vec::Vec<BlkioStatsEntry>,
    #[prost(message, repeated, tag = "5")]
    pub io_wait_time_recursive: ::prost::alloc::vec::Vec<BlkioStatsEntry>,
    #[prost(message, repeated, tag = "6")]
    pub io_merged_recursive: ::prost::alloc::vec::Vec<BlkioStatsEntry>,
    #[prost(message, repeated, tag = "7")]
    pub io_time_recursive: ::prost::alloc::vec::Vec<BlkioStatsEntry>,
    #[prost(message, repeated, tag = "8")]
    pub sectors_recursive: ::prost::alloc::vec::Vec<BlkioStatsEntry>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HugetlbStats {
    #[prost(uint64, tag = "1")]
    pub usage: u64,
    #[prost(uint64, tag = "2")]
    pub max_usage: u64,
    #[prost(uint64, tag = "3")]
    pub failcnt: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CgroupStats {
    #[prost(message, optional, tag = "1")]
    pub cpu_stats: ::core::option::Option<CpuStats>,
    #[prost(message, optional, tag = "2")]
    pub memory_stats: ::core::option::Option<MemoryStats>,
    #[prost(message, optional, tag = "3")]
    pub pids_stats: ::core::option::Option<PidsStats>,
    #[prost(message, optional, tag = "4")]
    pub blkio_stats: ::core::option::Option<BlkioStats>,
    /// the map is in the format "size of hugepage: stats of the hugepage"
    #[prost(map = "string, message", tag = "5")]
    pub hugetlb_stats: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        HugetlbStats,
    >,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkStats {
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub rx_bytes: u64,
    #[prost(uint64, tag = "3")]
    pub rx_packets: u64,
    #[prost(uint64, tag = "4")]
    pub rx_errors: u64,
    #[prost(uint64, tag = "5")]
    pub rx_dropped: u64,
    #[prost(uint64, tag = "6")]
    pub tx_bytes: u64,
    #[prost(uint64, tag = "7")]
    pub tx_packets: u64,
    #[prost(uint64, tag = "8")]
    pub tx_errors: u64,
    #[prost(uint64, tag = "9")]
    pub tx_dropped: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StatsContainerResponse {
    #[prost(message, optional, tag = "1")]
    pub cgroup_stats: ::core::option::Option<CgroupStats>,
    #[prost(message, repeated, tag = "2")]
    pub network_stats: ::prost::alloc::vec::Vec<NetworkStats>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteStreamRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exec_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteStreamResponse {
    #[prost(uint32, tag = "1")]
    pub len: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadStreamRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exec_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub len: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadStreamResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CloseStdinRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exec_id: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TtyWinResizeRequest {
    #[prost(string, tag = "1")]
    pub container_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub exec_id: ::prost::alloc::string::String,
    #[prost(uint32, tag = "3")]
    pub row: u32,
    #[prost(uint32, tag = "4")]
    pub column: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreateSandboxRequest {
    #[prost(string, tag = "1")]
    pub hostname: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub dns: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub storages: ::prost::alloc::vec::Vec<Storage>,
    /// This field means that a pause process needs to be created by the
    /// agent. This pid namespace of the pause process will be treated as
    /// a shared pid namespace. All containers created will join this shared
    /// pid namespace.
    #[prost(bool, tag = "4")]
    pub sandbox_pidns: bool,
    /// SandboxId identifies which sandbox is using the agent. We allow only
    /// one sandbox per agent and implicitly require that CreateSandbox is
    /// called before other sandbox/network calls.
    #[prost(string, tag = "5")]
    pub sandbox_id: ::prost::alloc::string::String,
    /// This field, if non-empty, designates an absolute path to a directory
    /// that the agent will search for OCI hooks to run within the guest.
    #[prost(string, tag = "6")]
    pub guest_hook_path: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DestroySandboxRequest {}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Interfaces {
    #[prost(message, repeated, tag = "1")]
    pub interfaces: ::prost::alloc::vec::Vec<super::types::Interface>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Routes {
    #[prost(message, repeated, tag = "1")]
    pub routes: ::prost::alloc::vec::Vec<super::types::Route>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateInterfaceRequest {
    #[prost(message, optional, tag = "1")]
    pub interface: ::core::option::Option<super::types::Interface>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UpdateRoutesRequest {
    #[prost(message, optional, tag = "1")]
    pub routes: ::core::option::Option<Routes>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListInterfacesRequest {}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListRoutesRequest {}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OnlineCpuMemRequest {
    /// Wait specifies if the caller waits for the agent to online all resources.
    /// If true the agent returns once all resources have been connected, otherwise all
    /// resources are connected asynchronously and the agent returns immediately.
    #[prost(bool, tag = "1")]
    pub wait: bool,
    /// NbCpus specifies the number of CPUs that were added and the agent has to online.
    #[prost(uint32, tag = "2")]
    pub nb_cpus: u32,
    /// CpuOnly specifies whether only online CPU or not.
    #[prost(bool, tag = "3")]
    pub cpu_only: bool,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReseedRandomDevRequest {
    /// Data specifies the random data used to reseed the guest crng.
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
/// AgentDetails provides information to the client about the running agent.
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentDetails {
    /// Semantic version of agent (see <https://semver.org>).
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// Set if the agent is running as PID 1.
    #[prost(bool, tag = "2")]
    pub init_daemon: bool,
    /// List of available device handlers.
    #[prost(string, repeated, tag = "3")]
    pub device_handlers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// List of available storage handlers.
    #[prost(string, repeated, tag = "4")]
    pub storage_handlers: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Set only if the agent is built with seccomp support and the guest
    /// environment supports seccomp.
    #[prost(bool, tag = "5")]
    pub supports_seccomp: bool,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestDetailsRequest {
    /// MemBlockSize asks server to return the system memory block size that can be used
    /// for memory hotplug alignment. Typically the server returns what's in
    /// /sys/devices/system/memory/block_size_bytes.
    #[prost(bool, tag = "1")]
    pub mem_block_size: bool,
    /// MemoryHotplugProbe asks server to return whether guest kernel supports memory hotplug
    /// via probeinterface. Typically the server will check if the path
    /// /sys/devices/system/memory/probe exists.
    #[prost(bool, tag = "2")]
    pub mem_hotplug_probe: bool,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GuestDetailsResponse {
    /// MemBlockSizeBytes returns the system memory block size in bytes.
    #[prost(uint64, tag = "1")]
    pub mem_block_size_bytes: u64,
    #[prost(message, optional, tag = "2")]
    pub agent_details: ::core::option::Option<AgentDetails>,
    #[prost(bool, tag = "3")]
    pub support_mem_hotplug_probe: bool,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MemHotplugByProbeRequest {
    /// server needs to send the value of memHotplugProbeAddr into file /sys/devices/system/memory/probe,
    /// in order to notify the guest kernel about hot-add memory event
    #[prost(uint64, repeated, tag = "1")]
    pub mem_hotplug_probe_addr: ::prost::alloc::vec::Vec<u64>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetGuestDateTimeRequest {
    /// Sec the second since the Epoch.
    #[prost(int64, tag = "1")]
    pub sec: i64,
    /// Usec the microseconds portion of time since the Epoch.
    #[prost(int64, tag = "2")]
    pub usec: i64,
}
/// Storage represents both the rootfs of the container, and any volume that
/// could have been defined through the Mount list of the OCI specification.
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Storage {
    /// Driver is used to define the way the storage is passed through the
    /// virtual machine. It can be "9p", "blk", or something else, but for
    /// all cases, this will define if some extra steps are required before
    /// this storage gets mounted into the container.
    #[prost(string, tag = "1")]
    pub driver: ::prost::alloc::string::String,
    /// DriverOptions allows the caller to define a list of options such
    /// as block sizes, numbers of luns, ... which are very specific to
    /// every device and cannot be generalized through extra fields.
    #[prost(string, repeated, tag = "2")]
    pub driver_options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Source can be anything representing the source of the storage. This
    /// will be handled by the proper handler based on the Driver used.
    /// For instance, it can be a very simple path if the caller knows the
    /// name of device inside the VM, or it can be some sort of identifier
    /// to let the agent find the device inside the VM.
    #[prost(string, tag = "3")]
    pub source: ::prost::alloc::string::String,
    /// Fstype represents the filesystem that needs to be used to mount the
    /// storage inside the VM. For instance, it could be "xfs" for block
    /// device, "9p" for shared filesystem, or "tmpfs" for shared /dev/shm.
    #[prost(string, tag = "4")]
    pub fstype: ::prost::alloc::string::String,
    /// Options describes the additional options that might be needed to
    /// mount properly the storage filesytem.
    #[prost(string, repeated, tag = "5")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// MountPoint refers to the path where the storage should be mounted
    /// inside the VM.
    #[prost(string, tag = "6")]
    pub mount_point: ::prost::alloc::string::String,
}
/// Device represents only the devices that could have been defined through the
/// Linux Device list of the OCI specification.
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Device {
    /// Id can be used to identify the device inside the VM. Some devices
    /// might not need it to be identified on the VM, and will rely on the
    /// provided VmPath instead.
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Type defines the type of device described. This can be "blk",
    /// "scsi", "vfio", ...
    /// Particularly, this should be used to trigger the use of the
    /// appropriate device handler.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// VmPath can be used by the caller to provide directly the path of
    /// the device as it will appear inside the VM. For some devices, the
    /// device id or the list of options passed might not be enough to find
    /// the device. In those cases, the caller should predict and provide
    /// this vm_path.
    #[prost(string, tag = "3")]
    pub vm_path: ::prost::alloc::string::String,
    /// ContainerPath defines the path where the device should be found inside
    /// the container. This path should match the path of the device from
    /// the device list listed inside the OCI spec. This is used in order
    /// to identify the right device in the spec and update it with the
    /// right options such as major/minor numbers as they appear inside
    /// the VM for instance. Note that an empty ctr_path should be used
    /// to make sure the device handler inside the agent is called, but
    /// no spec update needs to be performed. This has to happen for the
    /// case of rootfs, when a device has to be waited for after it has
    /// been hotplugged. An equivalent Storage entry should be defined if
    /// any mount needs to be performed afterwards.
    #[prost(string, tag = "4")]
    pub container_path: ::prost::alloc::string::String,
    /// Options allows the caller to define a list of options such as block
    /// sizes, numbers of luns, ... which are very specific to every device
    /// and cannot be generalized through extra fields.
    #[prost(string, repeated, tag = "5")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StringUser {
    #[prost(string, tag = "1")]
    pub uid: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gid: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "3")]
    pub additional_gids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CopyFileRequest {
    /// Path is the destination file in the guest. It must be absolute,
    /// canonical and below /run.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// FileSize is the expected file size, for security reasons write operations
    /// are made in a temporary file, once it has the expected size, it's moved
    /// to the destination path.
    #[prost(int64, tag = "2")]
    pub file_size: i64,
    /// FileMode is the file mode.
    #[prost(uint32, tag = "3")]
    pub file_mode: u32,
    /// DirMode is the mode for the parent directories of destination path.
    #[prost(uint32, tag = "4")]
    pub dir_mode: u32,
    /// Uid is the numeric user id.
    #[prost(int32, tag = "5")]
    pub uid: i32,
    /// Gid is the numeric group id.
    #[prost(int32, tag = "6")]
    pub gid: i32,
    /// Offset for the next write operation.
    #[prost(int64, tag = "7")]
    pub offset: i64,
    /// Data to write in the destination file.
    #[prost(bytes = "vec", tag = "8")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartTracingRequest {}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StopTracingRequest {}
use std::collections::HashMap;
use std::sync::Arc;
use prost::Message;
use async_trait::async_trait;
#[async_trait]
pub trait AgentService: Sync {
    async fn create_container(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: CreateContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/CreateContainer is not supported",
                ),
            ),
        )
    }
    async fn start_container(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: StartContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/StartContainer is not supported",
                ),
            ),
        )
    }
    async fn remove_container(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: RemoveContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/RemoveContainer is not supported",
                ),
            ),
        )
    }
    async fn exec_process(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: ExecProcessRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/ExecProcess is not supported",
                ),
            ),
        )
    }
    async fn signal_process(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: SignalProcessRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/SignalProcess is not supported",
                ),
            ),
        )
    }
    async fn wait_process(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: WaitProcessRequest,
    ) -> ::ttrpc::Result<WaitProcessResponse> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/WaitProcess is not supported",
                ),
            ),
        )
    }
    async fn list_processes(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: ListProcessesRequest,
    ) -> ::ttrpc::Result<ListProcessesResponse> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/ListProcesses is not supported",
                ),
            ),
        )
    }
    async fn update_container(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: UpdateContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/UpdateContainer is not supported",
                ),
            ),
        )
    }
    async fn stats_container(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: StatsContainerRequest,
    ) -> ::ttrpc::Result<StatsContainerResponse> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/StatsContainer is not supported",
                ),
            ),
        )
    }
    async fn pause_container(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: PauseContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/PauseContainer is not supported",
                ),
            ),
        )
    }
    async fn resume_container(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: ResumeContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/ResumeContainer is not supported",
                ),
            ),
        )
    }
    async fn write_stdin(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: WriteStreamRequest,
    ) -> ::ttrpc::Result<WriteStreamResponse> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/WriteStdin is not supported",
                ),
            ),
        )
    }
    async fn read_stdout(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: ReadStreamRequest,
    ) -> ::ttrpc::Result<ReadStreamResponse> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/ReadStdout is not supported",
                ),
            ),
        )
    }
    async fn read_stderr(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: ReadStreamRequest,
    ) -> ::ttrpc::Result<ReadStreamResponse> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/ReadStderr is not supported",
                ),
            ),
        )
    }
    async fn close_stdin(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: CloseStdinRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/CloseStdin is not supported",
                ),
            ),
        )
    }
    async fn tty_win_resize(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: TtyWinResizeRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/TtyWinResize is not supported",
                ),
            ),
        )
    }
    async fn update_interface(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: UpdateInterfaceRequest,
    ) -> ::ttrpc::Result<super::types::Interface> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/UpdateInterface is not supported",
                ),
            ),
        )
    }
    async fn update_routes(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: UpdateRoutesRequest,
    ) -> ::ttrpc::Result<Routes> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/UpdateRoutes is not supported",
                ),
            ),
        )
    }
    async fn list_interfaces(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: ListInterfacesRequest,
    ) -> ::ttrpc::Result<Interfaces> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/ListInterfaces is not supported",
                ),
            ),
        )
    }
    async fn list_routes(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: ListRoutesRequest,
    ) -> ::ttrpc::Result<Routes> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/ListRoutes is not supported",
                ),
            ),
        )
    }
    async fn start_tracing(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: StartTracingRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/StartTracing is not supported",
                ),
            ),
        )
    }
    async fn stop_tracing(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: StopTracingRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/StopTracing is not supported",
                ),
            ),
        )
    }
    async fn create_sandbox(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: CreateSandboxRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/CreateSandbox is not supported",
                ),
            ),
        )
    }
    async fn destroy_sandbox(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: DestroySandboxRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/DestroySandbox is not supported",
                ),
            ),
        )
    }
    async fn online_cpu_mem(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: OnlineCpuMemRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/OnlineCPUMem is not supported",
                ),
            ),
        )
    }
    async fn reseed_random_dev(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: ReseedRandomDevRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/ReseedRandomDev is not supported",
                ),
            ),
        )
    }
    async fn get_guest_details(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: GuestDetailsRequest,
    ) -> ::ttrpc::Result<GuestDetailsResponse> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/GetGuestDetails is not supported",
                ),
            ),
        )
    }
    async fn mem_hotplug_by_probe(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: MemHotplugByProbeRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/MemHotplugByProbe is not supported",
                ),
            ),
        )
    }
    async fn set_guest_date_time(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: SetGuestDateTimeRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/SetGuestDateTime is not supported",
                ),
            ),
        )
    }
    async fn copy_file(
        &self,
        _ctx: &::ttrpc::r#async::TtrpcContext,
        _: CopyFileRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        Err(
            ::ttrpc::Error::RpcStatus(
                ::ttrpc::get_status(
                    ::ttrpc::Code::NotFound,
                    "agent.AgentService/CopyFile is not supported",
                ),
            ),
        )
    }
}
struct CreateContainerMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for CreateContainerMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, CreateContainerRequest, create_container
        );
    }
}
struct StartContainerMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for StartContainerMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, StartContainerRequest, start_container
        );
    }
}
struct RemoveContainerMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for RemoveContainerMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, RemoveContainerRequest, remove_container
        );
    }
}
struct ExecProcessMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ExecProcessMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, ExecProcessRequest, exec_process
        );
    }
}
struct SignalProcessMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for SignalProcessMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, SignalProcessRequest, signal_process
        );
    }
}
struct WaitProcessMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for WaitProcessMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, WaitProcessRequest, wait_process
        );
    }
}
struct ListProcessesMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ListProcessesMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, ListProcessesRequest, list_processes
        );
    }
}
struct UpdateContainerMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for UpdateContainerMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, UpdateContainerRequest, update_container
        );
    }
}
struct StatsContainerMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for StatsContainerMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, StatsContainerRequest, stats_container
        );
    }
}
struct PauseContainerMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for PauseContainerMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, PauseContainerRequest, pause_container
        );
    }
}
struct ResumeContainerMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ResumeContainerMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, ResumeContainerRequest, resume_container
        );
    }
}
struct WriteStdinMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for WriteStdinMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, WriteStreamRequest, write_stdin);
    }
}
struct ReadStdoutMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ReadStdoutMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, ReadStreamRequest, read_stdout);
    }
}
struct ReadStderrMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ReadStderrMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, ReadStreamRequest, read_stderr);
    }
}
struct CloseStdinMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for CloseStdinMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, CloseStdinRequest, close_stdin);
    }
}
struct TtyWinResizeMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for TtyWinResizeMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, TtyWinResizeRequest, tty_win_resize
        );
    }
}
struct UpdateInterfaceMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for UpdateInterfaceMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, UpdateInterfaceRequest, update_interface
        );
    }
}
struct UpdateRoutesMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for UpdateRoutesMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, UpdateRoutesRequest, update_routes
        );
    }
}
struct ListInterfacesMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ListInterfacesMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, ListInterfacesRequest, list_interfaces
        );
    }
}
struct ListRoutesMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ListRoutesMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, ListRoutesRequest, list_routes);
    }
}
struct StartTracingMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for StartTracingMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, StartTracingRequest, start_tracing
        );
    }
}
struct StopTracingMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for StopTracingMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, StopTracingRequest, stop_tracing
        );
    }
}
struct CreateSandboxMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for CreateSandboxMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, CreateSandboxRequest, create_sandbox
        );
    }
}
struct DestroySandboxMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for DestroySandboxMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, DestroySandboxRequest, destroy_sandbox
        );
    }
}
struct OnlineCpuMemMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for OnlineCpuMemMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, OnlineCpuMemRequest, online_cpu_mem
        );
    }
}
struct ReseedRandomDevMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for ReseedRandomDevMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, ReseedRandomDevRequest, reseed_random_dev
        );
    }
}
struct GetGuestDetailsMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for GetGuestDetailsMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, GuestDetailsRequest, get_guest_details
        );
    }
}
struct MemHotplugByProbeMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for MemHotplugByProbeMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, MemHotplugByProbeRequest, mem_hotplug_by_probe
        );
    }
}
struct SetGuestDateTimeMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for SetGuestDateTimeMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(
            self, ctx, req, SetGuestDateTimeRequest, set_guest_date_time
        );
    }
}
struct CopyFileMethod {
    service: Arc<Box<dyn AgentService + Send + Sync>>,
}
#[async_trait]
impl ::ttrpc::r#async::MethodHandler for CopyFileMethod {
    async fn handler(
        &self,
        ctx: ::ttrpc::r#async::TtrpcContext,
        req: ::ttrpc::Request,
    ) -> ::ttrpc::Result<::ttrpc::Response> {
        ::ttrpc::async_request_handler!(self, ctx, req, CopyFileRequest, copy_file);
    }
}
pub fn create_agent_service(
    service: Arc<Box<dyn AgentService + Send + Sync>>,
) -> HashMap<String, ::ttrpc::r#async::Service> {
    let mut ret = HashMap::new();
    let mut methods = HashMap::new();
    let streams = HashMap::new();
    methods
        .insert(
            "CreateContainer".to_string(),
            Box::new(CreateContainerMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "StartContainer".to_string(),
            Box::new(StartContainerMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "RemoveContainer".to_string(),
            Box::new(RemoveContainerMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "ExecProcess".to_string(),
            Box::new(ExecProcessMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "SignalProcess".to_string(),
            Box::new(SignalProcessMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "WaitProcess".to_string(),
            Box::new(WaitProcessMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "ListProcesses".to_string(),
            Box::new(ListProcessesMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "UpdateContainer".to_string(),
            Box::new(UpdateContainerMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "StatsContainer".to_string(),
            Box::new(StatsContainerMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "PauseContainer".to_string(),
            Box::new(PauseContainerMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "ResumeContainer".to_string(),
            Box::new(ResumeContainerMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "WriteStdin".to_string(),
            Box::new(WriteStdinMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "ReadStdout".to_string(),
            Box::new(ReadStdoutMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "ReadStderr".to_string(),
            Box::new(ReadStderrMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "CloseStdin".to_string(),
            Box::new(CloseStdinMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "TtyWinResize".to_string(),
            Box::new(TtyWinResizeMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "UpdateInterface".to_string(),
            Box::new(UpdateInterfaceMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "UpdateRoutes".to_string(),
            Box::new(UpdateRoutesMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "ListInterfaces".to_string(),
            Box::new(ListInterfacesMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "ListRoutes".to_string(),
            Box::new(ListRoutesMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "StartTracing".to_string(),
            Box::new(StartTracingMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "StopTracing".to_string(),
            Box::new(StopTracingMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "CreateSandbox".to_string(),
            Box::new(CreateSandboxMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "DestroySandbox".to_string(),
            Box::new(DestroySandboxMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "OnlineCPUMem".to_string(),
            Box::new(OnlineCpuMemMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "ReseedRandomDev".to_string(),
            Box::new(ReseedRandomDevMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "GetGuestDetails".to_string(),
            Box::new(GetGuestDetailsMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "MemHotplugByProbe".to_string(),
            Box::new(MemHotplugByProbeMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "SetGuestDateTime".to_string(),
            Box::new(SetGuestDateTimeMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    methods
        .insert(
            "CopyFile".to_string(),
            Box::new(CopyFileMethod {
                service: service.clone(),
            }) as Box<dyn ::ttrpc::r#async::MethodHandler + Send + Sync>,
        );
    ret.insert(
        "agent.AgentService".to_string(),
        ::ttrpc::r#async::Service {
            methods,
            streams,
        },
    );
    ret
}
#[derive(Clone)]
pub struct AgentServiceClient {
    client: ::ttrpc::r#async::Client,
}
impl AgentServiceClient {
    pub fn new(client: ::ttrpc::r#async::Client) -> Self {
        AgentServiceClient { client }
    }
}
impl AgentServiceClient {
    pub async fn create_container(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &CreateContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "CreateContainer", cres
        );
    }
    pub async fn start_container(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &StartContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "StartContainer", cres
        );
    }
    pub async fn remove_container(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &RemoveContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "RemoveContainer", cres
        );
    }
    pub async fn exec_process(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &ExecProcessRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "ExecProcess", cres
        );
    }
    pub async fn signal_process(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &SignalProcessRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "SignalProcess", cres
        );
    }
    pub async fn wait_process(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &WaitProcessRequest,
    ) -> ::ttrpc::Result<WaitProcessResponse> {
        let mut cres = WaitProcessResponse::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "WaitProcess", cres
        );
    }
    pub async fn list_processes(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &ListProcessesRequest,
    ) -> ::ttrpc::Result<ListProcessesResponse> {
        let mut cres = ListProcessesResponse::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "ListProcesses", cres
        );
    }
    pub async fn update_container(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &UpdateContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "UpdateContainer", cres
        );
    }
    pub async fn stats_container(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &StatsContainerRequest,
    ) -> ::ttrpc::Result<StatsContainerResponse> {
        let mut cres = StatsContainerResponse::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "StatsContainer", cres
        );
    }
    pub async fn pause_container(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &PauseContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "PauseContainer", cres
        );
    }
    pub async fn resume_container(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &ResumeContainerRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "ResumeContainer", cres
        );
    }
    pub async fn write_stdin(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &WriteStreamRequest,
    ) -> ::ttrpc::Result<WriteStreamResponse> {
        let mut cres = WriteStreamResponse::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "WriteStdin", cres
        );
    }
    pub async fn read_stdout(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &ReadStreamRequest,
    ) -> ::ttrpc::Result<ReadStreamResponse> {
        let mut cres = ReadStreamResponse::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "ReadStdout", cres
        );
    }
    pub async fn read_stderr(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &ReadStreamRequest,
    ) -> ::ttrpc::Result<ReadStreamResponse> {
        let mut cres = ReadStreamResponse::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "ReadStderr", cres
        );
    }
    pub async fn close_stdin(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &CloseStdinRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "CloseStdin", cres
        );
    }
    pub async fn tty_win_resize(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &TtyWinResizeRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "TtyWinResize", cres
        );
    }
    pub async fn update_interface(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &UpdateInterfaceRequest,
    ) -> ::ttrpc::Result<super::types::Interface> {
        let mut cres = super::types::Interface::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "UpdateInterface", cres
        );
    }
    pub async fn update_routes(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &UpdateRoutesRequest,
    ) -> ::ttrpc::Result<Routes> {
        let mut cres = Routes::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "UpdateRoutes", cres
        );
    }
    pub async fn list_interfaces(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &ListInterfacesRequest,
    ) -> ::ttrpc::Result<Interfaces> {
        let mut cres = Interfaces::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "ListInterfaces", cres
        );
    }
    pub async fn list_routes(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &ListRoutesRequest,
    ) -> ::ttrpc::Result<Routes> {
        let mut cres = Routes::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "ListRoutes", cres
        );
    }
    pub async fn start_tracing(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &StartTracingRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "StartTracing", cres
        );
    }
    pub async fn stop_tracing(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &StopTracingRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "StopTracing", cres
        );
    }
    pub async fn create_sandbox(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &CreateSandboxRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "CreateSandbox", cres
        );
    }
    pub async fn destroy_sandbox(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &DestroySandboxRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "DestroySandbox", cres
        );
    }
    pub async fn online_cpu_mem(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &OnlineCpuMemRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "OnlineCPUMem", cres
        );
    }
    pub async fn reseed_random_dev(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &ReseedRandomDevRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "ReseedRandomDev", cres
        );
    }
    pub async fn get_guest_details(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &GuestDetailsRequest,
    ) -> ::ttrpc::Result<GuestDetailsResponse> {
        let mut cres = GuestDetailsResponse::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "GetGuestDetails", cres
        );
    }
    pub async fn mem_hotplug_by_probe(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &MemHotplugByProbeRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "MemHotplugByProbe", cres
        );
    }
    pub async fn set_guest_date_time(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &SetGuestDateTimeRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "SetGuestDateTime", cres
        );
    }
    pub async fn copy_file(
        &self,
        ctx: ::ttrpc::context::Context,
        req: &CopyFileRequest,
    ) -> ::ttrpc::Result<super::google::protobuf::Empty> {
        let mut cres = super::google::protobuf::Empty::default();
        ::ttrpc::async_client_request!(
            self, ctx, req, "agent.AgentService", "CopyFile", cres
        );
    }
}
