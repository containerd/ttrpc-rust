// This file is generated by ttrpc-codegen 1.0.0. Do not edit
// @generated

#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Spec {
    /// Version of the Open Container Initiative Runtime Specification with which the bundle complies.
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    /// Process configures the container process.
    #[prost(message, optional, tag = "2")]
    pub process: ::core::option::Option<Process>,
    /// Root configures the container's root filesystem.
    #[prost(message, optional, tag = "3")]
    pub root: ::core::option::Option<Root>,
    /// Hostname configures the container's hostname.
    #[prost(string, tag = "4")]
    pub hostname: ::prost::alloc::string::String,
    /// Mounts configures additional mounts (on top of Root).
    #[prost(message, repeated, tag = "5")]
    pub mounts: ::prost::alloc::vec::Vec<Mount>,
    /// Hooks configures callbacks for container lifecycle events.
    #[prost(message, optional, tag = "6")]
    pub hooks: ::core::option::Option<Hooks>,
    /// Annotations contains arbitrary metadata for the container.
    #[prost(map = "string, string", tag = "7")]
    pub annotations: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Linux is platform-specific configuration for Linux based containers.
    #[prost(message, optional, tag = "8")]
    pub linux: ::core::option::Option<Linux>,
    /// Solaris is platform-specific configuration for Solaris based containers.
    #[prost(message, optional, tag = "9")]
    pub solaris: ::core::option::Option<Solaris>,
    /// Windows is platform-specific configuration for Windows based containers.
    #[prost(message, optional, tag = "10")]
    pub windows: ::core::option::Option<Windows>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Process {
    /// Terminal creates an interactive terminal for the container.
    #[prost(bool, tag = "1")]
    pub terminal: bool,
    /// ConsoleSize specifies the size of the console.
    #[prost(message, optional, tag = "2")]
    pub console_size: ::core::option::Option<Box>,
    /// User specifies user information for the process.
    #[prost(message, optional, tag = "3")]
    pub user: ::core::option::Option<User>,
    /// Args specifies the binary and arguments for the application to execute.
    #[prost(string, repeated, tag = "4")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Env populates the process environment for the process.
    #[prost(string, repeated, tag = "5")]
    pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Cwd is the current working directory for the process and must be
    /// relative to the container's root.
    #[prost(string, tag = "6")]
    pub cwd: ::prost::alloc::string::String,
    /// Capabilities are Linux capabilities that are kept for the process.
    #[prost(message, optional, tag = "7")]
    pub capabilities: ::core::option::Option<LinuxCapabilities>,
    /// Rlimits specifies rlimit options to apply to the process.
    #[prost(message, repeated, tag = "8")]
    pub rlimits: ::prost::alloc::vec::Vec<PosixRlimit>,
    /// NoNewPrivileges controls whether additional privileges could be gained by processes in the container.
    #[prost(bool, tag = "9")]
    pub no_new_privileges: bool,
    /// ApparmorProfile specifies the apparmor profile for the container.
    #[prost(string, tag = "10")]
    pub apparmor_profile: ::prost::alloc::string::String,
    /// Specify an oom_score_adj for the container.
    #[prost(int64, tag = "11")]
    pub oom_score_adj: i64,
    /// SelinuxLabel specifies the selinux context that the container process is run as.
    #[prost(string, tag = "12")]
    pub selinux_label: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Box {
    /// Height is the vertical dimension of a box.
    #[prost(uint32, tag = "1")]
    pub height: u32,
    /// Width is the horizontal dimension of a box.
    #[prost(uint32, tag = "2")]
    pub width: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct User {
    /// UID is the user id.
    #[prost(uint32, tag = "1")]
    pub uid: u32,
    /// GID is the group id.
    #[prost(uint32, tag = "2")]
    pub gid: u32,
    /// AdditionalGids are additional group ids set for the container's process.
    #[prost(uint32, repeated, tag = "3")]
    pub additional_gids: ::prost::alloc::vec::Vec<u32>,
    /// Username is the user name.
    #[prost(string, tag = "4")]
    pub username: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxCapabilities {
    /// Bounding is the set of capabilities checked by the kernel.
    #[prost(string, repeated, tag = "1")]
    pub bounding: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Effective is the set of capabilities checked by the kernel.
    #[prost(string, repeated, tag = "2")]
    pub effective: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Inheritable is the capabilities preserved across execve.
    #[prost(string, repeated, tag = "3")]
    pub inheritable: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Permitted is the limiting superset for effective capabilities.
    #[prost(string, repeated, tag = "4")]
    pub permitted: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Ambient is the ambient set of capabilities that are kept.
    #[prost(string, repeated, tag = "5")]
    pub ambient: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PosixRlimit {
    /// Type of the rlimit to set
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Hard is the hard limit for the specified type
    #[prost(uint64, tag = "2")]
    pub hard: u64,
    /// Soft is the soft limit for the specified type
    #[prost(uint64, tag = "3")]
    pub soft: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Mount {
    /// destination is the path inside the container expect when it starts with "tmp:/"
    #[prost(string, tag = "1")]
    pub destination: ::prost::alloc::string::String,
    /// source is the path inside the container expect when it starts with "vm:/dev/" or "tmp:/"
    /// the path which starts with "vm:/dev/" refers the guest vm's "/dev",
    /// especially, "vm:/dev/hostfs/" refers to the shared filesystem.
    /// "tmp:/" is a temporary directory which is used for temporary mounts.
    #[prost(string, tag = "2")]
    pub source: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub r#type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Root {
    /// Path is the absolute path to the container's root filesystem.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Readonly makes the root filesystem for the container readonly before the process is executed.
    #[prost(bool, tag = "2")]
    pub readonly: bool,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hooks {
    /// Prestart is a list of hooks to be run before the container process is executed.
    #[prost(message, repeated, tag = "1")]
    pub prestart: ::prost::alloc::vec::Vec<Hook>,
    /// Poststart is a list of hooks to be run after the container process is started.
    #[prost(message, repeated, tag = "2")]
    pub poststart: ::prost::alloc::vec::Vec<Hook>,
    /// Poststop is a list of hooks to be run after the container process exits.
    #[prost(message, repeated, tag = "3")]
    pub poststop: ::prost::alloc::vec::Vec<Hook>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Hook {
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub timeout: i64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Linux {
    /// UIDMapping specifies user mappings for supporting user namespaces.
    #[prost(message, repeated, tag = "1")]
    pub uid_mappings: ::prost::alloc::vec::Vec<LinuxIdMapping>,
    /// GIDMapping specifies group mappings for supporting user namespaces.
    #[prost(message, repeated, tag = "2")]
    pub gid_mappings: ::prost::alloc::vec::Vec<LinuxIdMapping>,
    /// Sysctl are a set of key value pairs that are set for the container on start
    #[prost(map = "string, string", tag = "3")]
    pub sysctl: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Resources contain cgroup information for handling resource constraints
    /// for the container
    #[prost(message, optional, tag = "4")]
    pub resources: ::core::option::Option<LinuxResources>,
    /// CgroupsPath specifies the path to cgroups that are created and/or joined by the container.
    /// The path is expected to be relative to the cgroups mountpoint.
    /// If resources are specified, the cgroups at CgroupsPath will be updated based on resources.
    #[prost(string, tag = "5")]
    pub cgroups_path: ::prost::alloc::string::String,
    /// Namespaces contains the namespaces that are created and/or joined by the container
    #[prost(message, repeated, tag = "6")]
    pub namespaces: ::prost::alloc::vec::Vec<LinuxNamespace>,
    /// Devices are a list of device nodes that are created for the container
    #[prost(message, repeated, tag = "7")]
    pub devices: ::prost::alloc::vec::Vec<LinuxDevice>,
    /// Seccomp specifies the seccomp security settings for the container.
    #[prost(message, optional, tag = "8")]
    pub seccomp: ::core::option::Option<LinuxSeccomp>,
    /// RootfsPropagation is the rootfs mount propagation mode for the container.
    #[prost(string, tag = "9")]
    pub rootfs_propagation: ::prost::alloc::string::String,
    /// MaskedPaths masks over the provided paths inside the container.
    #[prost(string, repeated, tag = "10")]
    pub masked_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// ReadonlyPaths sets the provided paths as RO inside the container.
    #[prost(string, repeated, tag = "11")]
    pub readonly_paths: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// MountLabel specifies the selinux context for the mounts in the container.
    #[prost(string, tag = "12")]
    pub mount_label: ::prost::alloc::string::String,
    /// IntelRdt contains Intel Resource Director Technology (RDT) information
    /// for handling resource constraints (e.g., L3 cache) for the container
    #[prost(message, optional, tag = "13")]
    pub intel_rdt: ::core::option::Option<LinuxIntelRdt>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Windows {
    /// Dummy string, never used.
    #[prost(string, tag = "1")]
    pub dummy: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Solaris {
    /// Dummy string, never used.
    #[prost(string, tag = "1")]
    pub dummy: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxIdMapping {
    /// HostID is the starting UID/GID on the host to be mapped to 'ContainerID'
    #[prost(uint32, tag = "1")]
    pub host_id: u32,
    /// ContainerID is the starting UID/GID in the container
    #[prost(uint32, tag = "2")]
    pub container_id: u32,
    /// Size is the number of IDs to be mapped
    #[prost(uint32, tag = "3")]
    pub size: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxNamespace {
    /// Type is the type of namespace
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// Path is a path to an existing namespace persisted on disk that can be joined
    /// and is of the same type
    #[prost(string, tag = "2")]
    pub path: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxDevice {
    /// Path to the device.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Device type, block, char, etc.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// Major is the device's major number.
    #[prost(int64, tag = "3")]
    pub major: i64,
    /// Minor is the device's minor number.
    #[prost(int64, tag = "4")]
    pub minor: i64,
    /// FileMode permission bits for the device.
    #[prost(uint32, tag = "5")]
    pub file_mode: u32,
    /// UID of the device.
    #[prost(uint32, tag = "6")]
    pub uid: u32,
    /// Gid of the device.
    #[prost(uint32, tag = "7")]
    pub gid: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxResources {
    /// Devices configures the device whitelist.
    #[prost(message, repeated, tag = "1")]
    pub devices: ::prost::alloc::vec::Vec<LinuxDeviceCgroup>,
    /// Memory restriction configuration
    #[prost(message, optional, tag = "2")]
    pub memory: ::core::option::Option<LinuxMemory>,
    /// CPU resource restriction configuration
    #[prost(message, optional, tag = "3")]
    pub cpu: ::core::option::Option<LinuxCpu>,
    /// Task resource restriction configuration.
    #[prost(message, optional, tag = "4")]
    pub pids: ::core::option::Option<LinuxPids>,
    /// BlockIO restriction configuration
    #[prost(message, optional, tag = "5")]
    pub block_io: ::core::option::Option<LinuxBlockIo>,
    /// Hugetlb limit (in bytes)
    #[prost(message, repeated, tag = "6")]
    pub hugepage_limits: ::prost::alloc::vec::Vec<LinuxHugepageLimit>,
    /// Network restriction configuration
    #[prost(message, optional, tag = "7")]
    pub network: ::core::option::Option<LinuxNetwork>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxMemory {
    /// Memory limit (in bytes).
    #[prost(int64, tag = "1")]
    pub limit: i64,
    /// Memory reservation or soft_limit (in bytes).
    #[prost(int64, tag = "2")]
    pub reservation: i64,
    /// Total memory limit (memory + swap).
    #[prost(int64, tag = "3")]
    pub swap: i64,
    /// Kernel memory limit (in bytes).
    #[prost(int64, tag = "4")]
    pub kernel: i64,
    /// Kernel memory limit for tcp (in bytes)
    #[prost(int64, tag = "5")]
    pub kernel_tcp: i64,
    /// How aggressive the kernel will swap memory pages.
    #[prost(uint64, tag = "6")]
    pub swappiness: u64,
    /// DisableOOMKiller disables the OOM killer for out of memory conditions
    #[prost(bool, tag = "7")]
    pub disable_oom_killer: bool,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxCpu {
    /// CPU shares (relative weight (ratio) vs. other cgroups with cpu shares).
    #[prost(uint64, tag = "1")]
    pub shares: u64,
    /// CPU hardcap limit (in usecs). Allowed cpu time in a given period.
    #[prost(int64, tag = "2")]
    pub quota: i64,
    /// CPU period to be used for hardcapping (in usecs).
    #[prost(uint64, tag = "3")]
    pub period: u64,
    /// How much time realtime scheduling may use (in usecs).
    #[prost(int64, tag = "4")]
    pub realtime_runtime: i64,
    /// CPU period to be used for realtime scheduling (in usecs).
    #[prost(uint64, tag = "5")]
    pub realtime_period: u64,
    /// CPUs to use within the cpuset. Default is to use any CPU available.
    #[prost(string, tag = "6")]
    pub cpus: ::prost::alloc::string::String,
    /// List of memory nodes in the cpuset. Default is to use any available memory node.
    #[prost(string, tag = "7")]
    pub mems: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxWeightDevice {
    /// Major is the device's major number.
    #[prost(int64, tag = "1")]
    pub major: i64,
    /// Minor is the device's minor number.
    #[prost(int64, tag = "2")]
    pub minor: i64,
    /// Weight is the bandwidth rate for the device.
    #[prost(uint32, tag = "3")]
    pub weight: u32,
    /// LeafWeight is the bandwidth rate for the device while competing with the cgroup's child cgroups, CFQ scheduler only
    #[prost(uint32, tag = "4")]
    pub leaf_weight: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxThrottleDevice {
    /// Major is the device's major number.
    #[prost(int64, tag = "1")]
    pub major: i64,
    /// Minor is the device's minor number.
    #[prost(int64, tag = "2")]
    pub minor: i64,
    /// Rate is the IO rate limit per cgroup per device
    #[prost(uint64, tag = "3")]
    pub rate: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxBlockIo {
    /// Specifies per cgroup weight
    #[prost(uint32, tag = "1")]
    pub weight: u32,
    /// Specifies tasks' weight in the given cgroup while competing with the cgroup's child cgroups, CFQ scheduler only
    #[prost(uint32, tag = "2")]
    pub leaf_weight: u32,
    /// Weight per cgroup per device, can override BlkioWeight
    #[prost(message, repeated, tag = "3")]
    pub weight_device: ::prost::alloc::vec::Vec<LinuxWeightDevice>,
    /// IO read rate limit per cgroup per device, bytes per second
    #[prost(message, repeated, tag = "4")]
    pub throttle_read_bps_device: ::prost::alloc::vec::Vec<LinuxThrottleDevice>,
    /// IO write rate limit per cgroup per device, bytes per second
    #[prost(message, repeated, tag = "5")]
    pub throttle_write_bps_device: ::prost::alloc::vec::Vec<LinuxThrottleDevice>,
    /// IO read rate limit per cgroup per device, IO per second
    #[prost(message, repeated, tag = "6")]
    pub throttle_read_iops_device: ::prost::alloc::vec::Vec<LinuxThrottleDevice>,
    /// IO write rate limit per cgroup per device, IO per second
    #[prost(message, repeated, tag = "7")]
    pub throttle_write_iops_device: ::prost::alloc::vec::Vec<LinuxThrottleDevice>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxPids {
    /// Maximum number of PIDs. Default is "no limit".
    #[prost(int64, tag = "1")]
    pub limit: i64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxDeviceCgroup {
    /// Allow or deny
    #[prost(bool, tag = "1")]
    pub allow: bool,
    /// Device type, block, char, etc.
    #[prost(string, tag = "2")]
    pub r#type: ::prost::alloc::string::String,
    /// Major is the device's major number.
    #[prost(int64, tag = "3")]
    pub major: i64,
    /// Minor is the device's minor number.
    #[prost(int64, tag = "4")]
    pub minor: i64,
    /// Cgroup access permissions format, rwm.
    #[prost(string, tag = "5")]
    pub access: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxNetwork {
    /// Set class identifier for container's network packets
    #[prost(uint32, tag = "1")]
    pub class_id: u32,
    /// Set priority of network traffic for container
    #[prost(message, repeated, tag = "2")]
    pub priorities: ::prost::alloc::vec::Vec<LinuxInterfacePriority>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxHugepageLimit {
    /// Pagesize is the hugepage size
    #[prost(string, tag = "1")]
    pub pagesize: ::prost::alloc::string::String,
    /// Limit is the limit of "hugepagesize" hugetlb usage
    #[prost(uint64, tag = "2")]
    pub limit: u64,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxInterfacePriority {
    /// Name is the name of the network interface
    #[prost(string, tag = "1")]
    pub name: ::prost::alloc::string::String,
    /// Priority for the interface
    #[prost(uint32, tag = "2")]
    pub priority: u32,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxSeccomp {
    #[prost(string, tag = "1")]
    pub default_action: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub architectures: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub syscalls: ::prost::alloc::vec::Vec<LinuxSyscall>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxSeccompArg {
    #[prost(uint64, tag = "1")]
    pub index: u64,
    #[prost(uint64, tag = "2")]
    pub value: u64,
    #[prost(uint64, tag = "3")]
    pub value_two: u64,
    #[prost(string, tag = "4")]
    pub op: ::prost::alloc::string::String,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxSyscall {
    #[prost(string, repeated, tag = "1")]
    pub names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "2")]
    pub action: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<LinuxSeccompArg>,
}
#[derive(::serde::Serialize, ::serde::Deserialize)]
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LinuxIntelRdt {
    /// The schema for L3 cache id and capacity bitmask (CBM)
    /// Format: "L3:<cache_id0>=<cbm0>;<cache_id1>=<cbm1>;..."
    #[prost(string, tag = "1")]
    pub l3_cache_schema: ::prost::alloc::string::String,
}
