use anyhow::{anyhow, Context, Result};
use prost::Message;
use prost_build::Config;
use prost_types::FileDescriptorSet;
use std::{
    fs::{self, File},
    io::{BufReader, Read, Write},
    path::{Path, PathBuf},
};

use crate::svcgen::{AsyncMode, TtrpcServiceGenerator};

const FILE_DESCRIPTOR_SET: &str = "fd_set.bin";

pub struct Codegen<'a, P: AsRef<Path>> {
    out_dir: &'a P,
    protos: &'a [P],
    includes: &'a [P],
    /// Whether to enable serde
    serde: bool,
    async_mode: AsyncMode,
    /// Whether to generate service
    generate_service: bool,
}

impl<'a, P> Codegen<'a, P>
where
    P: AsRef<Path>,
{
    pub fn generate(&self) -> Result<()> {
        self.compile_protos().context("Compile protos")?;
        self.write_header().context("Write header")?;
        self.clean_up().context("Clean up")?;

        Ok(())
    }

    // TODO: Do not write header to the files that already has the header
    // TODO: Write header to the files generated by the codegen
    fn write_header(&self) -> Result<()> {
        // Read fd_set.bin
        let f = File::open(PathBuf::from(self.out_dir.as_ref()).join(FILE_DESCRIPTOR_SET))
            .context("Open fd_set.bin")?;
        let mut reader = BufReader::new(f);
        let mut buffer = Vec::new();
        reader.read_to_end(&mut buffer).context("Read fd_set.bin")?;

        let fd_set = FileDescriptorSet::decode(&buffer as &[u8]).context("Decode fd_set")?;

        for fd in fd_set.file.iter() {
            let rs_path =
                PathBuf::from(self.out_dir.as_ref()).join(&format!("{}.rs", fd.package()));
            let mut f = match File::open(&rs_path) {
                Ok(f) => f,
                _ => continue,
            };
            let header = format!(
                r#"// This file is generated by ttrpc-codegen {}. Do not edit
// @generated

"#,
                env!("CARGO_PKG_VERSION")
            );

            let mut buf = Vec::<u8>::new();
            buf.write(header.as_bytes()).context("Write header")?;
            f.read_to_end(&mut buf)
                .context(format!("Read from rust file {:?}", rs_path))?;
            let mut f = File::create(&rs_path).context(format!("Open rust file {:?}", rs_path))?;
            f.write_all(buf.as_slice())
                .context(format!("Write to rust file {:?}", rs_path))?;
        }

        Ok(())
    }

    fn compile_protos(&self) -> Result<()> {
        let mut config = Config::new();
        config.out_dir(self.out_dir.as_ref());
        config.service_generator(Box::new(TtrpcServiceGenerator::new(self.async_mode)));
        config.protoc_arg("--experimental_allow_proto3_optional");
        config.compile_well_known_types();
        config.file_descriptor_set_path(
            PathBuf::from(self.out_dir.as_ref()).join(FILE_DESCRIPTOR_SET),
        );
        if self.generate_service {
            config.include_file("_include.rs");
            if self.serde {
                config
                    .message_attribute(".", "#[derive(::serde::Serialize, ::serde::Deserialize)]");
            }
        }
        config
            .compile_protos(self.protos, self.includes)
            .context("Compile protos by prost")?;
        Ok(())
    }

    fn clean_up(&self) -> Result<()> {
        fs::remove_file(PathBuf::from(self.out_dir.as_ref()).join(FILE_DESCRIPTOR_SET))
            .context("Remove fd_set.bin")?;
        Ok(())
    }
}

#[derive(Default)]
pub struct CodegenBuilder<'a, P: AsRef<Path> + Default> {
    out_dir: Option<&'a P>,
    protos: Option<&'a [P]>,
    includes: Option<&'a [P]>,
    /// Whether to enable serde
    serde: Option<bool>,
    async_mode: Option<AsyncMode>,
    /// Whether to generate service
    generate_service: Option<bool>,
}

impl<'a, P> CodegenBuilder<'a, P>
where
    P: AsRef<Path> + Default,
{
    pub fn new() -> Self {
        Default::default()
    }

    pub fn set_out_dir(mut self, out_dir: &'a P) -> Self {
        self.out_dir = Some(out_dir);
        self
    }

    pub fn set_protos(mut self, protos: &'a [P]) -> Self {
        self.protos = Some(protos);
        self
    }

    pub fn set_includes(mut self, includes: &'a [P]) -> Self {
        self.includes = Some(includes);
        self
    }

    pub fn set_serde(mut self, serde: bool) -> Self {
        self.serde = Some(serde);
        self
    }

    pub fn set_async_mode(mut self, async_mode: AsyncMode) -> Self {
        self.async_mode = Some(async_mode);
        self
    }

    pub fn set_generate_service(mut self, generate_service: bool) -> Self {
        self.generate_service = Some(generate_service);
        self
    }

    pub fn build(&self) -> Result<Codegen<'a, P>> {
        let out_dir = match self.out_dir {
            Some(out_dir) => out_dir,
            None => return Err(anyhow!("The out dir is required.")),
        };

        let protos = match self.protos {
            Some(protos) => protos,
            None => return Err(anyhow!("The protos are required.")),
        };

        let includes = match self.includes {
            Some(includes) => includes,
            None => return Err(anyhow!("The includes are required.")),
        };

        let serde = match self.serde {
            Some(serde) => serde,
            None => false,
        };

        let async_mode = match self.async_mode {
            Some(mode) => mode,
            None => AsyncMode::None,
        };

        let generate_service = match self.generate_service {
            Some(gen) => gen,
            None => false,
        };

        Ok(Codegen {
            out_dir,
            protos,
            includes,
            serde,
            async_mode,
            generate_service,
        })
    }
}
